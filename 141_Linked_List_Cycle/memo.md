## Step 1 メモ

### クラス命名と型アノテーションの重要性

読む側の視点として、初めに与えられている `ListNode` クラスの定義がわかりにくかった。

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

これのわかりにくいところは、
- `next` は何を期待しているのかが一見わからない
- `ListNode` というクラス名からは複数ノードを持つデータ構造が連想されるが、実態は単一ノードである

改善するとしたら、

```python
class Node:
    def __init__(self, value: int):
        self.value = value
        self.next: Optional[Node] = None  # あるいは self.next: Node | None = None
```

とするのが良さそう。

## Step 2 メモ

### クラスオブジェクトの同一性に関する疑問

fast と slow が一致した時にループがあるとして検出しているが、それぞれは `ListNode` オブジェクトである。

```python
...
    if fast == slow:
        return True
...
```

ここで気になるのが、`==` 演算子がクラスオブジェクトの同一性を比較している点である。クラスオブジェクトの同一性を比較する場合、何を持って同一としているのか曖昧に感じた。 プログラム実行時には全てのノードを初期化しているはずなので、ハッシュ値的なものを比較している？

→ Python ではオブジェクトの一意な識別子 (CPythonだとメモリ上のアドレス) を返す `id()` 関数が組み込みで用意されている。同じオブジェクトでも `id()` の返す値が異なることもあり、この場合にはメモリ上の異なるアドレスに格納されていることを意味する。なので例えば以下のようなことが起こる。

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a
print(id(a) == id(b))  # False
print(id(a) == id(c))  # True
```

今回だと `==` で比較しているが、この場合にはクラスの `__eq__` メソッドが呼ばれる。`__eq__` メソッドが定義されていない場合、デフォルトで `is` 演算子と同じ動作をするため、オブジェクトの同一性を比較、つまりidの比較をしていることになる。
ちなみに `is` 演算子を使うとオブジェクトの同一性を比較できる。

参考：
- [Pythonのid()とは？](https://trends.codecamp.jp/blogs/media/terminology565)
- [同一性の比較](https://docs.python.org/ja/3/reference/expressions.html#is-not)
- [3. データモデル](https://docs.python.org/ja/3/reference/datamodel.html)


### アルゴリズムについて

現在のアルゴリズムは、一回で2歩進む fast と一回で1歩進む slow を用い、ループがある場合には折り返しが発生していつか fast と slow が一致するだろうという考え。なぜ fast は2歩なのかというと、slow を跨いで追い越すことがなくなるから。

```
ループ折り返し後に追いつくパターン:

---o---o---o---
   ^   ^
   f   s

---o---o---o---  追いつく。
           ^
           fs

```

また、このアルゴリズムは最悪ケース = slow がループの一周分進んだ場合であり、その場合でもループに入るまでの比較回数分 + ループ一周分の比較回数分で済むため、ループの長さをnとすれば、O(n) 時間で解決できると考えられる。
