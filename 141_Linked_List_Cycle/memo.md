## Step 1 メモ

### クラス命名と型アノテーションの重要性

読む側の視点として、初めに与えられている `ListNode` クラスの定義がわかりにくかった。

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

これのわかりにくいところは、
- `next` は何を期待しているのかが一見わからない
- `ListNode` というクラス名からは複数ノードを持つデータ構造が連想されるが、実態は単一ノードである

改善するとしたら、

```python
class Node:
    def __init__(self, value: int):
        self.value = value
        self.next: Optional[Node] = None  # あるいは self.next: Node | None = None
```

とするのが良さそう。

## Step 2 メモ

### オブジェクトの同一性に関する疑問

fast と slow が一致した時にループがあるとして検出しているが、それぞれは `ListNode` オブジェクトである。

```python
...
    if fast == slow:
        return True
...
```

ここで気になるのが、`==` 演算子がオブジェクトの同一性を比較している点である。オブジェクトの同一性を比較する場合、何を持って同一としているのか曖昧に感じた。 プログラム実行時には全てのノードを初期化しているはずなので、ハッシュ値的なものを比較している？

### アルゴリズムについて

現在のアルゴリズムは、一回で2歩進む fast と一回で1歩進む slow を用い、ループがある場合には折り返しが発生していつか fast と slow が一致するだろうという考え。なぜ fast は2歩なのかというと、slow を跨いで追い越すことがなくなるから。

```
ループ折り返し後に追いつくパターン:

---o---o---o---
   ^   ^
   f   s

---o---o---o---  追いつく。
           ^
           fs

```

また、このアルゴリズムは最悪ケース = slow がループの一周分進んだ場合であり、その場合でもループに入るまでの比較回数分 + ループ一周分の比較回数分で済むため、ループの長さをnとすれば、O(n) 時間で解決できると考えられる。
